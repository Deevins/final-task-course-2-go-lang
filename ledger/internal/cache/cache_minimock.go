// Code generated by minimock. DO NOT EDIT.
// Source: github.com/Deevins/final-task-course-2-go-lang/ledger/internal/cache (interfaces: ReportSummaryCache,BudgetListCache)

package cache

import (
	"context"
	"sync"

	"github.com/gojuno/minimock/v3"

	"github.com/Deevins/final-task-course-2-go-lang/ledger/internal/model"
)

// ReportSummaryCacheMock implements ReportSummaryCache.
type ReportSummaryCacheMock struct {
	t minimock.Tester

	GetSummaryFunc func(ctx context.Context, key string) (model.ReportSummary, error)
	SetSummaryFunc func(ctx context.Context, key string, summary model.ReportSummary) error

	getSummaryMu sync.Mutex
	getSummaryN  int
	setSummaryMu sync.Mutex
	setSummaryN  int
}

// NewReportSummaryCacheMock returns a new mock.
func NewReportSummaryCacheMock(t minimock.Tester) *ReportSummaryCacheMock {
	return &ReportSummaryCacheMock{t: t}
}

// GetSummary implements ReportSummaryCache.
func (m *ReportSummaryCacheMock) GetSummary(ctx context.Context, key string) (model.ReportSummary, error) {
	m.getSummaryMu.Lock()
	m.getSummaryN++
	m.getSummaryMu.Unlock()

	if m.GetSummaryFunc == nil {
		m.t.Fatalf("GetSummaryFunc is not set")
		return model.ReportSummary{}, nil
	}
	return m.GetSummaryFunc(ctx, key)
}

// SetSummary implements ReportSummaryCache.
func (m *ReportSummaryCacheMock) SetSummary(ctx context.Context, key string, summary model.ReportSummary) error {
	m.setSummaryMu.Lock()
	m.setSummaryN++
	m.setSummaryMu.Unlock()

	if m.SetSummaryFunc == nil {
		m.t.Fatalf("SetSummaryFunc is not set")
		return nil
	}
	return m.SetSummaryFunc(ctx, key, summary)
}

// GetSummaryCalls returns number of calls to GetSummary.
func (m *ReportSummaryCacheMock) GetSummaryCalls() int {
	m.getSummaryMu.Lock()
	defer m.getSummaryMu.Unlock()
	return m.getSummaryN
}

// SetSummaryCalls returns number of calls to SetSummary.
func (m *ReportSummaryCacheMock) SetSummaryCalls() int {
	m.setSummaryMu.Lock()
	defer m.setSummaryMu.Unlock()
	return m.setSummaryN
}

// BudgetListCacheMock implements BudgetListCache.
type BudgetListCacheMock struct {
	t minimock.Tester

	GetBudgetsFunc    func(ctx context.Context) ([]model.Budget, error)
	SetBudgetsFunc    func(ctx context.Context, budgets []model.Budget) error
	DeleteBudgetsFunc func(ctx context.Context) error

	getBudgetsMu    sync.Mutex
	getBudgetsN     int
	setBudgetsMu    sync.Mutex
	setBudgetsN     int
	deleteBudgetsMu sync.Mutex
	deleteBudgetsN  int
}

// NewBudgetListCacheMock returns a new mock.
func NewBudgetListCacheMock(t minimock.Tester) *BudgetListCacheMock {
	return &BudgetListCacheMock{t: t}
}

// GetBudgets implements BudgetListCache.
func (m *BudgetListCacheMock) GetBudgets(ctx context.Context) ([]model.Budget, error) {
	m.getBudgetsMu.Lock()
	m.getBudgetsN++
	m.getBudgetsMu.Unlock()

	if m.GetBudgetsFunc == nil {
		m.t.Fatalf("GetBudgetsFunc is not set")
		return nil, nil
	}
	return m.GetBudgetsFunc(ctx)
}

// SetBudgets implements BudgetListCache.
func (m *BudgetListCacheMock) SetBudgets(ctx context.Context, budgets []model.Budget) error {
	m.setBudgetsMu.Lock()
	m.setBudgetsN++
	m.setBudgetsMu.Unlock()

	if m.SetBudgetsFunc == nil {
		m.t.Fatalf("SetBudgetsFunc is not set")
		return nil
	}
	return m.SetBudgetsFunc(ctx, budgets)
}

// DeleteBudgets implements BudgetListCache.
func (m *BudgetListCacheMock) DeleteBudgets(ctx context.Context) error {
	m.deleteBudgetsMu.Lock()
	m.deleteBudgetsN++
	m.deleteBudgetsMu.Unlock()

	if m.DeleteBudgetsFunc == nil {
		m.t.Fatalf("DeleteBudgetsFunc is not set")
		return nil
	}
	return m.DeleteBudgetsFunc(ctx)
}

// GetBudgetsCalls returns number of calls to GetBudgets.
func (m *BudgetListCacheMock) GetBudgetsCalls() int {
	m.getBudgetsMu.Lock()
	defer m.getBudgetsMu.Unlock()
	return m.getBudgetsN
}

// SetBudgetsCalls returns number of calls to SetBudgets.
func (m *BudgetListCacheMock) SetBudgetsCalls() int {
	m.setBudgetsMu.Lock()
	defer m.setBudgetsMu.Unlock()
	return m.setBudgetsN
}

// DeleteBudgetsCalls returns number of calls to DeleteBudgets.
func (m *BudgetListCacheMock) DeleteBudgetsCalls() int {
	m.deleteBudgetsMu.Lock()
	defer m.deleteBudgetsMu.Unlock()
	return m.deleteBudgetsN
}
